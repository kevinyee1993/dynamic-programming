<!DOCTYPE html>
<html lang="en" dir="ltr">
  <head>
    <meta charset="utf-8">
    <title></title>
    <script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"></script>
    <link rel="stylesheet" href="./styles.css">
  </head>

  <body>
    <div id="app">
      <div>
        <button type="button"
        @click="startEffect"
        :class="effectProperty">
          Start Effect
        </button>

        <div id="effect"></div>
      </div>

      <div :class="[{ box: boxOn }, { green: greenOn }]">I've got no class :)!!</div>


      <div>
        <input type="text" v-model="userSubmittedClass1">
        <div :class="userSubmittedClass1"></div>
      </div>

      <div>
        <input type="text" v-model="userSubmittedClass2">
        <input type="text" v-model="userSubmittedBoolean">
        <div :class="userSubmitted"></div>
      </div>

      <div>
        <input type="text" v-model="colorStyleValue">
        <input type="text" v-model="widthStyleValue">
        <div class="box" :style="{ backgroundColor: colorStyleValue, width: widthStyleValue + 'px' }"></div>
      </div>

      <div>
        <button type="button" @click="startProgress">Start Progress</button>
        <p>Progress percent: {{ progressPercent }}%</p>
        <div class="progress-bar" :style="{ width: (progressPercent * 3) + 'px' }"></div>
      </div>
    </div>

    <script type="text/javascript">
      const app = new Vue({
        el: '#app',
        data: {
          highlightStatus: false,
          shrinkStatus: false,
          boxOn: true,
          greenOn: true,
          userSubmittedClass1: null,
          userSubmittedClass2: null,
          userSubmittedBoolean: false,
          colorStyleValue: null,
          widthStyleValue: null,
          progressPercent: 0
        },
        methods: {
          startEffect: function() {
            this.highlightStatus = true;
            setInterval( () => {
              if(this.highlightStatus) {
                this.highlightStatus = false;
                this.shrinkStatus = true;
              } else {
                this.highlightStatus = true;
                this.shrinkStatus = false;
              }
            }, 2000);
          },
          startProgress: function() {
            setInterval(() => {
              if(this.progressPercent < 100) {
                this.progressPercent += 10;
              }
            },1000);
          }
        },
        computed: {
          effectProperty: function() {
            return { highlight: this.highlightStatus, shrink: this.shrinkStatus }
          },
          userSubmitted: function() {
            let strToBool = this.userSubmittedBoolean === 'true' ? true : false;
            return [this.userSubmittedClass2, { green: strToBool }];
          }
        }
      });
    </script>
  </body>
</html>
<!-- Topics Learned

$event
event handler modifiers (v-on:click.stop or v-on:click.prevent)
v-model (v-model='name')
computed vs methods
v-html

watch
shorthand for event listener and v-bind (@ and :)

binding data or computed properties to classes or styles



v-binding with classes and passing in object
:class="{ className: boolean }"
i wonder if you could do multiple classes like this -> you could by doing this
:class="{ className1: boolean, className2: boolean }"
NOPE
on html part, if you want to v-bind multiple classes you need to use array syntax
:class="[{ className1: boolean }, { className2: boolean }, computedProperty]"

don't have to do array syntax with styles though so you can do something like this
:style="{ backgroundColor: colorStyleValue, width: widthStyleValue + 'px' }"
 -->


<!--
when want to pass in args to something you want to also use the event of, pass
in whatever args you want and then pass in $event too to get access to events

even more general, just whenever you wanna access the default JS event object, just use $event
v-on:keydown.enter="value = $event.target.value"

another note on this is that you dont always have to pass in a function to have
these event listeners work, you can just do the code within the quotes like that
note that when in the html, don't have to say this.value just need to say value
whereas in the vue object, you use this when the data spans across data and method objects yadadamean

there are event modifiers to stuff like v-on:whatever
just add a dot modifier to it and you can do stuff like
v-on:mousemove.stop which stops propagation
v-on:click:prevent which prevents default

there is an event modifier for keyup and i assume keydown too where you do something
like this:
v-on:keyup.enter where the modifier is the name of the key youre listening to
can chain as well like v-on:keyup.enter.a.shift

v-model on an input does 2 way binding of the input and the value associated with it
v-model="name" makes it so if you change name, you change the input and vice versa
it's the same as if you did <input type="text" v-bind:value="name" v-on:input="name = $event.target.value" />

for v-html you can't just pass in the html into the argument like
v-html="<p>henlo</p>", looks like you can only pass it in as variable like
v-html="html" where html is a data element with value of <p>henlo</p>

computed options object
can also add computed in addition to el, data, and methods
when interpolating data that relies on logic, might make sense to create
a method that returns a value and interpolate that in the dom using {{ method() }}
the only problem with this is that whenever ANYTHING on the page re-renders,
this method will be called even though whatever was changed may not be
relevant to the method
If the method takes a long time to run, this could negatively affect performance
because you do one little thing and it calls this function needlessly
This is where computed comes in.  Computed is used as a data when interpolating
onto the DOM e.g. {{ computedMethod }} instead of {{ computedMethod() }}
but when writing it out in the object, it still looks like a function.
Computed functions are not always called indiscriminately when something on the
page re-renders.  It is only called when relevant data is changed.  Relevant
data is anything contained or referenced within the computed function.  This
makes it so that when something unrelated rerenders, the computed function would
only run if any of its relvant data is changed, otherwise it will return the
cached previous result.  This saves a lot of time because it does not have
to take time to call the function again but just return this value.

watch is another property on the vue instance
it is similar to computed in that it executes some function when a relevant
data is updated but in general you just want to use computed
you want to use watched for async or expensive functions - computed is normally
something you want displayed immediately so you dont want to have it wait for
anything when you use.
computed: {
  // value is something that is given which is the new changed value of
  the data being watched for coming in
  nameOfDataToWatchFor: function(value) {
    //excute some async function here
    // usually might want to create reference to this
    const vm = this;

    // async function here
    setTimeout(function() {
      vm.whatever = 0
  }, 2000)
  }

  matter of fact you don't even have access to watch like that because it doesn't
  have a unique name, only the name of a property.  So it strictly does a function
  which you can't interpolate similarly to a method or a computed.  watch methods wouldn't return anything it seems

  shorthand for event listener:
  v-on:click="" can be shortened to @click=""

  shorthand for v-bind:attribute=""
  :attribute=""

  all computed properties are functions that return something

  turns out you can watch a computed value just like it was a regular piece of data
  but you can't just update it like computedValue = whatever regularly -> might
  be a way by using setters but im not sure right now

  for classes, can v-bind multiple classes with an array
  :className="[{attr1: true}, {attr2: true}, {attr3: true}]"
  or can combine with computed elements as well like
  :className="[computedValue1, {attr2: true}, {attr3: true}]"

  can also v-bind to style like this using objects
  :style="{backgroundColor: dataName}"
  note that youre not using css name background-color but using camelcase
  can also combine too like v-binding class name either with objects or computed
  property which returns an object in an array
  :style="[{ backgroundColor: red }, computed1, { width: widthData }]"
  if you're using a computed property to calculate more than one style, don't
  do array representation, it should just look like an object with multiple key-value pairs like this:

  myStyle: function() {
    return { backgroundColor: this.color,
    width: this.width + 'px'}
  }

  the array syntax is for when you're working on the html like
  <div :style="computedProperty1, { backgroundColor: red }">


}
-->
